#  计算机网络自顶向下方法

## 第一章 计算机网络和因特网

### 1.1 什么是因特网

- 我们能够描述因特网的具体构成，及构成因特网的基本硬件和软件组件
- 我们能够根据为分布式应用提供服务的联网基础设施来描述因特网

#### 1.1.1 具体构成描述

​	*端系统*通过**通信链路**和**分组交换机**连接到一起。不同的链路能够以不同的速率传输数据，链路的**传输速率**为比特/秒（*bit/s*，或*bps*）度量。当一台端系统向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节。由此形成的信息包称为**分组**。这些分组通过网络发送到目的端系统，在那里被装配成初始数据。

> ​	在当今的因特网中，两种最著名的*分组*交换机类型是**路由器**和**链路层交换机**。这两种类型的交换机朝着最终目的地转发*分组*。

#### 1.1.3 什么是协议

> ​	协议定义了在两个或多个通行实体之间交换的报文的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作。

​	掌握计算机网络领域知识的过程就是理解网络协议的构成、原理和工作方式的过程。

### 1.2 网络边缘

​	通常把与因特网相连的计算机和其他设备称为端系统。因为他们位于因特网的边缘，故而被称为端系统。

#### 1.2.2 物理媒体

​	物理媒体分为两种类型：**引导型媒体**和**非引导型媒体**。对于引导型媒体，电波沿着固体媒体前行，如光缆、双绞铜线或同轴电缆。对于非引导型媒体，电波在空气或外层空间中传播，例如在无线局域网或数字卫星频道中。

### 1.3 网络核心

​	我们现在更深入地研究网络核心，*即由互联因特网端系统的分组交换机和链路构成的网状网路*。

#### 1.3.1 分组交换

​	在各种网络应用中，端系统彼此交换**报文**。报文能够包含协议设计者需要的任何东西。为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为**分组**。*在源和目的地之间，每个分组都通过通信链路和分组交换机传送*。

 1. 存储转发传输

    ​	多数分组交换机在链路的输入端使用**存储转发传输**机制。存储转发传输是指*在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组*。

    ​	我们现在来考虑下列一般情况：通过有*N*条速率均为*R*的链路组成的路径（所以，在源和目的地之间有*N-1*台路由器），从源到目的地发送一个分组。应用如上相同的逻辑，我们看到端到端时延是：

    ​						*d`端到端`* = *N \* L/R*

	2. 排队时延和分组丢失

    ​	每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个**输出缓存**，它用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待。因此，除了存储转发时延以外，分组还要承受输出缓存的**排队时延**。这些时延取决于网络的拥塞程度。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了。此时，将出现**分组丢失（丢包）**，到达的分组或已经排队的分组之一将被丢弃。

	3. 转发表和路由选择协议

    ​	每台路由器具有一个**转发表**，用于将目的地址（或目的地址的一部分）映射成为输出链路。当某分组到达一台路由器时，路由器检查该地址，并用这个目的地址搜索其转发表，以发现适当的出链路。路由器则将分组导向该出链路。

    ​	一个**路由选择协议**可以决定从每台路由器到每个目的地的**最短路径**，并使用这些最短路径结果来配置路由器的转发表。

#### 1.3.2 电路交换

​	通过网络链路和交换机移动数据有两种基本方法：**电路交换**和**分组交换**。

​	在电路交换网络中，在端系统间通信会话期间，预留了端系统间沿路径通信所需要的资源（缓存，链路传输速率）。在分组交换网络中，这些资源则不是预留的：会话的报文按需使用这些资源，其后果可能是不得不等待（即排队）接入通信线路。

 1. 电路交换网络中的复用

    ​	链路中的电路是通过**频分复用（*FDM*）**或**时分复用（*TDM*）**来实现的。对于*FDM*，链路的频谱由跨越链路创建的所有连接共享。特别是，在连接期间链路为每条连接专用一个频段。

    ​	对于一条*TDM*链路，时间被划分为固定期间的帧，并且每个帧又被划分为固定数量的时隙。当网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。一条电路的传输速率等于帧速率乘以一个时隙中的比特数量。

	2. 分组交换与电路交换的对比

    	1. 分组交换提供了比电路交换更好的带宽共享

    	2. 分组交换比电路交换更简单、更有效，实现成本更低

        电路交换不考虑需求，而预先分配了传输链路的使用，这使得已分配而并不需要的链路时间未被利用。另一方面，分组交换按需分配链路使用。链路传输能力将在所有需要在链路上传输分组的用户之间逐分组地被共享。

### 1.4 分组交换网中的时延、丢包和吞吐量

#### 1.4.1 分组交换网中的时延概念

​	当分组从一个节点（主机或路由器）沿着这条路径到后继节点，该分组在沿途的每个节点经受了几种不同类型的时延。这些时延最为重要的是节点**处理时延**、**排队时延**、**传输时延**和**传播时延**，这些时延总体累加起来是**节点总时延**。为了深入理解分组交换和计算机网络，我们必须理解这些时延的性质和重要性。

##### 时延的类型

 1. 处理时延		

    ​	检查分组首部和决定将该分组导向何处所需要的时间是**处理时延**的一部分。高速路由器的处理时延通常是微妙或更低的数量级。在这种节点处理之后，路由器将该分组引向通往路由器B链路之前的队列。

	2. 排队时延

    ​	在队列中，当分组在链路上等待传输时，它经受**排队时延**。一个特定分组的排队时延长度将取决于先期到达的正在排队等待向链路传输的分组数量。到达分组期待发现的分组数量是到达该队列的流量的强度和性质的函数。实际的排队时延可以是毫秒到微秒量级。

	3. 传输时延

    ​	用L比特表示该分组的长度，用 *R bps*（即*b/s*）表示从路由器 *A*到路由器 *B*的链路传输速率。**传输时延**是 *L/R*。*这是将所有的分组的比特推向链路（及传输，或者说发射）所需要的时间*。实际的传输时延通常在毫秒到微妙量级。

	4. 传播时延

    ​	一旦一个比忒被推向链路，该比特需要向路由器*B*传播。从该链路的起点到路由器*B*传播所需要的时间是**传播时延**。该比特以链路的传播速率传播。该传播速率取决于该链路的物理媒体，其速率范围等于或略小于光速。传播时延是*d/s*，其中*d*是路由器A到路由器*B*之间的距离，s是该链路的传播速率。在广域网中，传播时延为毫秒量级。

	5. 传输时延和传播时延的比较

    ​	**传输时延**是路由器推出分组所需要的时间，**它是分组长度和链路传输速率的函数，而与两台路由器之间的距离无关**。**传播时延**是一个比特从一台路由器传播到另一台路由器所需要的时间，**它是两台路由器之间距离的函数，而与分组长度或链路传输速率无关**。

    这些时延成分所起的作用可能会有很大的不同。例如，对于连接两台位于同一个大学校园的路由器的链路而言，传播时延可能是微不足道的（例如，及微妙）；然而，对于由同步卫星链路互联的两台路由器来说，传播时延是几百微妙，能够成为节点总时延的主要成分。

#### 1.4.2 排队时延和丢包

​	令*a*表示分组到达队列的平均速率（以 *bps*即 *b/s*为单位）。则比特到达队列的平均速率是*La bps*。比率*La / R* 被称为**流量强度**，它在估计排队时延的范围方面经常起着重要的作用。如果 *La / R > 1*，则比特到达队列的平均速率超过从该队列传输出去的速率。在这种不幸的情况下，该队列趋向于无线增加，并且排队时延将趋向无穷大！**因此，流量工程的一条金科玉律是：设计系统时流量强度不能大于 *1***。

##### 丢包

​	排队流量是有限的，随着流量强度接近*1*，排队时延并不真正趋向无穷大。相反，到达的分组将发现一个满的队列。由于没有地方存储这个分组，路由器将**丢弃**该分组，即该分组将会**丢失**。分组丢失的比例随着流量强度增加而增加。*因此，一个节点的性能常常不仅根据时延来度量，而且根据丢包的概率来度量*。

#### 1.4.4 计算机网络中的吞吐量

​	除了时延和丢包，计算机网络中另一个至关重要的性能测度是端到端吞吐量。对于简单的两链路网络，其吞吐量是 *min {Rc, Rs}* (传输速率小的那个)，这就是说，它是**瓶颈链路**的传输速率。假定在通信网络核心中的所有链路具有非常高的传输速率，因为计算机网络的核心就像一个粗大的管子，所以比特从源向目的地的流动速率仍然是较小的那个，即吞吐量是 *min {Rc, Rs}* 。因此，**在今天因特网中对吞吐量的限制因素通常是接入网**。

​	如果公共链路的速率*R*很大，比如比其他的大*100*倍，则每个下载的吞吐量将任然是*min {Rc, Rs}* 。而公共链路的速率与其他的速率有相同量级。这时每个下载的瓶颈不在位于接入网中，而是位于核心中的共享链路了，所有的下载将共享此链路。

​	当没有其他干扰流量时，其吞吐量能够近似为沿着源和目的地之间路径的最小传输速率。吞吐量不仅取决于沿着路径的传输速率，还取决于干扰流量。特别是，如果许多其他的数据流也通过这条链路流动，**一条具有高传输速率的链路** *仍然可能成为文件传输的瓶颈链路*。

### 1.5 协议层次及其服务模型

#### 1.5.1 分层的体系结构

​	利用分层的体系结构，我们可以讨论一个大而复杂系统的定义良好的特定部分。这种简化本身由于提供模块化而具有很高价值，这使某层所提供的服务实现易于改变。对于大而复杂且需要不断更新的系统，改变服务的实现而不影响该系统其他组件是分层的另一个重要优点。

##### 协议分层

​	为了给网络协议的设计提供一个结构，网络设计者以**分层**的方式组织协议以及实现这些协议的网络硬件和软件。每个协议属于这些层次之一。我们关注某层向它的上一层提供的**服务**，即所谓一层的**服务模型**。

​	一个协议层能够用软件、硬件或两者的结合来实现。各层的所有协议被称为**协议栈**。因特网的协议由*5*个层次组层：物理层、链路层、网络层、传输层和引用层。

1. 应用层

   ​	应用层是网络应用程序及他们的应用协议留存的地方。*应用层协议分布在多个端系统上，而一个端系统中的应用程序使用协议与另一个端系统中的应用程序交换信息分组。我们把这种位于应用层的信息分组称为**报文***。

2. 运输层

   ​	因特网的运输层在应用程序端点之间传送应用层报文。在因特网中，有两种运输层协议，即*TCP*和*UDP*，利用其中的任一个都能运输应用层报文。我们把运输层的分组称为**报文段**。

3.  网络层

   ​	因特网的网络层负责将称为**数据报**的网络层分组从一台主机移动到另一台主机。在一台源主机中的因特网运输层协议（*TCP* 或 *UDP*）向网络层递交运输层报文段和目的地址。

4. 链路层

   ​	为了将分组从一个节点移动到路径上的下一个节点，网络层必须依靠该链路层的服务。特别是在每个节点，网络层将数据报下传给链路层，链路层沿着路径将数据报传递给下一个节点。在该下一个节点，链路层将数据报上传给网络层。

   ​	有链路层提供的服务取决于应用于该链路的特定链路层协议。我们把链路层分组称为**帧**。

5. 物理层

   ​	虽然链路层的任务是将整个帧从一个网络元素移动到邻近的网络元素，而物理层的任务是将该帧中的一个个比特从一个节点移动到下一个节点。在这层中的协议仍然是链路相关的，并且进一步与该链路（例如，双绞铜线、单模光纤）的实际传输媒体相关。

##### OSI模型

​	*OSI*参考模型的*7*层是：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层。

#### 1.5.2 封装

​	在每一层，一个分组具有两种类型的字段：首部字段和**有效载荷字段**。有效载荷通常是来自上一层的分组。

## 第二章 应用层

### 2.2 *Web*和*HTTP*

#### 2.2.1 *HTTP*概况

​	*Web*的应用层协议是**超文本传输协议（*HTTP*）**，它是Web的核心。*HTTP由两个程序实现：一个客户程序和一个服务器程序*。

​	***Web*浏览器实现了*HTTP*的客户端。Web服务器实现了HTTP的服务器端**，它用于存储Web对象，每个对象由*URL*寻址。

​	*HTTP*使用*TCP*作为它的支撑运输协议。

​	**服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息。因为*HTTP*服务器并不保存关于客户的任何信息，所以我们说*HTTP*是一个无状态协议**。

#### 2.2.2 非持续连接和持续连接

​	*HTTP*既能够使用非持续连接，也能够使用持续连接。尽管*HTTP*在其默认方式下使用持续连接，*HTTP*客户和服务器也能配置成使用非持续连接。

1. **采用非持续连接的*HTTP***

   ​	**每个*TCP*连接只传输一个请求报文和一个响应报文，每个*TCP*连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来**。

   ​	非持续连接有一些缺点。**第一，必须为每一个请求的对象建立和维护一个全新的连接。第二，每一个对象经受两倍*RTT*的交付时延，即一个*RTT*用于创建*TCP*，另一个*RTT*用于请求和接收一个对象**。

2. **采用持续连接的*HTTP***

   ​	在采用*HTTP1.1*持续连接的情况下，服务器在发送响应后保持该*TCP*连接打开。**在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。一般来说，如果一条连接经过一定时间间隔（一个可配置的超时间隔）仍未被使用，*HTTP*服务器就关闭该连接。*HTTP*的默认模式是使用带流水线的持续连接**。

#### 2.2.3 *HTTP*报文格式

​	***HTTP*报文有两种：请求报文和响应报文。**

1. ***HTTP*请求报文**

   ​	下面是一个典型的***HTTP*请求报文**：

   ```http
   GET /somedir/page.html HTTP/1.1
   Host: www.someschool.edu
   Connection: close
   User-agent: Mozilla/5.0
   Accept-language: fr
   ```

   ​	**虽然这个特定的报文仅有5行，但一个请求报文能够具有更多的的行或者至少为一行。*HTTP*请求报文的第一行叫做请求行，其后继的行叫做首部行。请求行有三个字段：方法字段、*URL*字段和*HTTP*版本字段。**

   ​	首部行*Host*指明了对象所在的主机；*Connection：close*首部行，该浏览器告诉服务器不要麻烦地使用持续连接（采用非持续连接）。*User-agent*首部行用来指明用户代理，即向服务器发送请求的浏览器类型。*Accept-language*首部行表示用户得到该对象的语言版本。

2. ***HTTP响应报文**

   ​	下面是一个典型的***HTTP*响应报文**：

   ```http
   HTTP/1.1 200 OK
   Connection: close
   Date: Tue, 18 Aug 2015 15:44:04 GMT
   Server: Apache/2.2.3 (CentOS)
   Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
   Content-Length: 6821
   Content-Type: text/html
   
   (data data data data data data ...)
   ```

   ​	**它有三个部分：一个初始状态行，*6*个首部行，然后是实体体*（entity body）*。实体体包含了所请求的对象本身。状态行有三个字段：协议版本字段、状态码和响应的状态信息。**

   ​	*Connection：close* 首部行告诉客户，发送完报文后将关闭该*TCP*连接。*Date* 表示服务器产生并发送该响应报文的日期和时间，**这个时间是服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该报文的时间。** *Server* 指示该报文由什么服务器产生，它类似于*HTTP*请求报文的*User-agent* 首部行。*Last-Modified* 指示了对象创建或者最后修改的日期和时间。**该首部行对既可能在本地客户也可能在网络缓存服务器上的对象缓存来说非常重要。** *Content-Length* 指示了被发送对象中的字节数。*Content-Type* 指示了实体体中的对象类型格式。

   ​	状态码及其相应的短语指示了请求的结果。一些常见的状态码和相关的短语包括：

    - *200 OK*：请求成功，信息在返回的响应报文中
    - *301 Moved Permanently*：请求的对象已经被永久转移了，新的*URL*定义在响应豹纹的*Location*首部行中。客户软件将自动获取新的*URL*
    - *400 Bad Request*：一个通用差错代码，指示该请求不能被服务器理解
    - *404 Not Found*：被请求的文档不在服务器上
    - *505 HTTP Version Not Supported*：服务器不支持请求报文使用的*HTTP*协议版本

####  2.2.4 用户与服务器的交互：*cookie*

#### 2.2.5 *Web*缓存

​	***Web*缓存器**也叫**代理服务器**，它是能够代表初始*Web*服务器来满足*HTTP*请求的网络实体。*Web*缓存器可以大大减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与*Web*缓存器之间的瓶颈带宽时更是如此。*Web*缓存器能从整体上大大减低因特网上的*Web*流量，从而改善了所有应用的性能。

#### 2.2.6 条件*GET*方法

​	*HTTP*协议有一种机制，允许缓存器证实它的对象是最新的。这种机制就是条件*GET*方法。如果：请求报文使用*GET*方法，并且请求报文包含一个*”If-Modified-Since:“* 首部行。那么，这个*HTTP*请求报文就是一个条件*GET*请求报文。

​	由于位于*Web*服务器上的对象可能已经被修改了，缓存器通过发送一个条件GET执行最新检查。具体来说该缓存器发送：

```http
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Web, 9 Sep 2015 09:23:24
```

条件*GET*报文告诉服务器，仅当自指定日期之后该对象被修改过，才发送该对象。若没有修改过，*Web*服务器想该缓存器发送一个相应报文：

```http
HTTP/1.1 304 Not Modified
Date: Sat, 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)

(empty entity body)
```

状态行中为*304 Not Modified*，它告诉缓存器可以使用该对象，能向请求的浏览器转发它缓存的该对象副本。

